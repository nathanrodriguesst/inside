#include "data/ExploitScanRepository.h"
#include <mariadb/conncpp.hpp>
#include <iostream>
#include "utils/TimeUtils.h"

void to_json(nlohmann::json& j, const ExploitScan& e) {
    j = nlohmann::json{
            {"id", e.id},
            {"activityType", e.activityType},
            {"activityTarget", e.activityTarget},
            {"activityDate", e.activityDate},
            {"exploited", e.exploited}
    };
}

std::vector<ExploitScan> ExploitScanRepository::selectFromActivitiesTable(
        const std::unique_ptr<sql::Connection> &connection
) {
    if (!connection) {
        std::cerr << "Invalid database connection" << std::endl;
        return {};
    }

    try {
        std::string query;
        std::vector<ExploitScan> results;

        std::unique_ptr<sql::Statement> stmt(connection->createStatement());
        query = "SELECT id, activityType, activityTarget, activityDate, exploited FROM recentActivities";

        std::unique_ptr<sql::ResultSet> res(stmt->executeQuery(query));

        while (res->next()) {
            ExploitScan exploitData;
            exploitData.id = res->getInt("id");
            exploitData.activityType = res->getString("activityType");
            exploitData.activityTarget = res->getString("activityTarget");
            exploitData.activityDate = res->getString("activityDate");
            exploitData.exploited = res->getBoolean("exploited");
            results.push_back(exploitData);
        }

        return results;
    } catch (sql::SQLException& e) {
        std::cerr << "Error executing query: " << e.what() << std::endl;
        return {};
    }
}

std::vector<ExploitScan> ExploitScanRepository::selectFromActivitiesTableByDateAndType(
        const std::unique_ptr<sql::Connection> &connection, const std::string& startDate,
        const std::string& endDate, const std::string& type
) {
    try {
        std::string query;
        std::vector<ExploitScan> results;

        std::unique_ptr<sql::PreparedStatement> preparedStatement(connection->prepareStatement(
                "SELECT id, activityType, activityTarget, activityDate, exploited FROM recentActivities "
                "WHERE activityType = ? AND DATE(activityDate) BETWEEN ? AND ?"));

        preparedStatement->setString(1, type);
        preparedStatement->setString(2, startDate);
        preparedStatement->setString(3, endDate);

        std::unique_ptr<sql::ResultSet> res(preparedStatement->executeQuery());

        while (res->next()) {
            ExploitScan exploitData;
            exploitData.id = res->getInt("id");
            exploitData.activityType = res->getString("activityType");
            exploitData.activityTarget = res->getString("activityTarget");
            exploitData.activityDate = res->getString("activityDate");
            exploitData.exploited = res->getBoolean("exploited");

            results.push_back(exploitData);
        }

        return results;
    } catch (sql::SQLException& e) {
        std::cerr << "Error executing query: " << e.what() << std::endl;
        return {};
    }
}

void
ExploitScanRepository::createExploitScanRegister(
        const std::unique_ptr<sql::Connection> &conn, std::string &ip,
        std::string &activityType, bool &exploitResult
) {
    if (!conn) {
        std::cerr << "Invalid database connection" << std::endl;
        return;
    }

    try {
        std::string currentTimeDate = TimeUtils::getCurrentDateTime();

        std::unique_ptr<sql::PreparedStatement> preparedStatement(conn->prepareStatement(
                "INSERT INTO recentActivities (activityType, activityTarget, exploited, activityDate) "
                "VALUES (?, ?, ?, STR_TO_DATE(?, '%d%m%Y%H%i%s%f'))"));

        preparedStatement->setString(1, activityType);
        preparedStatement->setString(2, ip);
        preparedStatement->setBoolean(3, exploitResult);
        preparedStatement->setString(4, currentTimeDate);


        preparedStatement->executeUpdate();
        std::cout << "Inserted record successfully." << std::endl;
    } catch (sql::SQLException& e) {
        std::cerr << "Error executing query: " << e.what() << std::endl;
    }
}

int ExploitScanRepository::selectCountExploits(const std::unique_ptr<sql::Connection> &connection) {
    if (!connection) {
        std::cerr << "Invalid database connection" << std::endl;
        return {};
    }

    try {
        std::unique_ptr<sql::Statement> stmt(connection->createStatement());
        std::string query = "SELECT COUNT(*) AS total FROM recentActivities WHERE activityType = \"Exploit\" ";
        std::unique_ptr<sql::ResultSet> res(stmt->executeQuery(query));

        if (res->next()) {
            int totalRecords = res->getInt("total");
            return totalRecords;
        }
    } catch (sql::SQLException& e) {
        std::cerr << "Error executing query: " << e.what() << std::endl;
        return {};
    }

    return 0;
}

int ExploitScanRepository::selectCountScans(const std::unique_ptr<sql::Connection> &connection) {
    if (!connection) {
        std::cerr << "Invalid database connection" << std::endl;
        return {};
    }

    try {
        std::unique_ptr<sql::Statement> stmt(connection->createStatement());
        std::string query = "SELECT COUNT(*) AS total FROM recentActivities WHERE activityType = \"Scan\" ";
        std::unique_ptr<sql::ResultSet> res(stmt->executeQuery(query));

        if (res->next()) {
            int totalRecords = res->getInt("total");
            return totalRecords;
        }
    } catch (sql::SQLException& e) {
        std::cerr << "Error executing query: " << e.what() << std::endl;
        return {};
    }

    return 0;
}